#include <stdlib.h>
#include <math.h>
#include <errno.h>

#include <string>
using namespace std;

#include "pngwriter.h"

#include "utility.hpp"
#include "outstreams.hpp"
#include "coordinates.hpp"
#include "SC2Map.hpp"



// constants relating to the image frame
int SC2Map::iDimT = 8;
int SC2Map::iDimC = 6;

/////////////////////////////////////////////////
//
//  NOTE!  The image frame is really a canvas
//  of pixels, but in the final out PNG there
//  will be borders and text outside the canvas.
//  Don't include these borders in the base
//  coordinate translations because we want to be
//  able to adjust the borders as we decide how
//  to render the image--and probably render
//  several images, each with different possible
//  border settings.
//
/////////////////////////////////////////////////

int SC2Map::iLeft   = 0;
int SC2Map::iBottom = 0;
int SC2Map::iRight  = 0;
int SC2Map::iTop    = 0;


int SC2Map::iFooterHeight = 68;


// when plotting shortest paths this constant is
// related to dealing with patch distances
static const float dNoOverride = -1.0f;




// use this to take a point.ix -> outPNG coordinates

// note that the grid of terrain is shifted by half a
// unit to the cell grid, and we let the playable
// terrain surround the playable cells, so there is an
// extra half-unit of terrain going all the way around
// the cell grid, account for this in the shift
int SC2Map::ix2png( int ix ) {
  return iLeft + 1 + iDimT/2 + ix;
}
int SC2Map::iy2png( int iy ) {
  return iBottom + 1 + iDimT/2 + iy;
}



void SC2Map::resetPNGWriter( const char* strFileSuffix,
                             int         iBorderLeft,
                             int         iBorderRight,
                             int         iBorderTop,
                             int         iBorderBottom ) {
  string strOut( outputPath );
  strOut += "\\" + this->mapNameInOutputFiles + strFileSuffix + ".png";

  img->pngwriter_rename( strOut.data() );

  // this resize of the image buffer implicitly colors
  // all pixels black
  img->resize( txDimPlayable*iDimT + iBorderLeft   + iBorderRight,
               tyDimPlayable*iDimT + iBorderBottom + iBorderTop );

  iLeft   = iBorderLeft;
  iBottom = iBorderBottom;
  iRight  = iBorderLeft   + txDimPlayable*iDimT;
  iTop    = iBorderBottom + tyDimPlayable*iDimT;
}






void SC2Map::renderFooter() {

  char versions[2*FILENAME_LENGTH];
  sprintf( versions,
           "generated by SC2 Map Analyzer, exe v%s, algorithms v%s",
           QUOTEMACRO( VEXE ),
           QUOTEMACRO( VALG ) );

  plotText( versions,
            14,          // font size
            false,       // centered,
            20, 42,      // bottom-left
            0.0f,        // angle
            getColor( "footerTxtFg" ),
            getColor( "footerTxtBg" ) );

  char url[FILENAME_LENGTH];
  strcpy( url, projectURL );
  plotText( url,
            14,          // font size
            false,       // centered,
            20, 20,      // bottom-left
            0.0f,        // angle
            getColor( "footerTxtFg" ),
            getColor( "footerTxtBg" ) );
}


void SC2Map::renderImageTerrainOnly() {

  resetPNGWriter( "-terrain-only",
                  20, 20,
                  58,
                  iFooterHeight );

  char title[2*FILENAME_LENGTH];
  sprintf( title,
           "%s - Terrain only",
           mapName.data() );

  plotText( title,
            18,          // font size
            false,       // centered,
            20, iTop+20, // bottom-left
            0.0f,        // angle
            getColor( "defaultTxtFg" ),
            getColor( "defaultTxtBg" ) );

  renderTerrain();
  renderFooter();
  img->close();
}


void SC2Map::renderImagesPathing() {
  renderImagePathing( "-pathingGroundWithRocks",            PATH_GROUND_WITHROCKS             );
  renderImagePathing( "-pathingGroundNoRocks",              PATH_GROUND_NOROCKS               );
  renderImagePathing( "-pathingCliffWalkWithRocks",         PATH_CWALK_WITHROCKS              );
  renderImagePathing( "-pathingCliffWalkNoRocks",           PATH_CWALK_NOROCKS                );
  renderImagePathing( "-pathingGroundWithRocksNoResources", PATH_GROUND_WITHROCKS_NORESOURCES );
  renderImagePathing( "-pathingBuildable",                  PATH_BUILDABLE                    );
  renderImagePathing( "-pathingMainBuildings",              PATH_BUILDABLE_MAIN               );
}

void SC2Map::renderImagePathing( const char* strOutPNG,
                                 PathType    t ) {
                                 
  resetPNGWriter( strOutPNG,
                  20, 20,
                  58,
                  iFooterHeight );

  char strPath[64];
  switch( t )
  {
    case PATH_GROUND_WITHROCKS:
    {
      sprintf( strPath, "Ground pathing, with rocks" );
    } break;

    case PATH_GROUND_NOROCKS:
    {
      sprintf( strPath, "Ground pathing, without rocks" );
    } break;

    case PATH_CWALK_WITHROCKS:
    {
      sprintf( strPath, "Cliff-walk pathing, with rocks" );
    } break;

    case PATH_CWALK_NOROCKS:
    {
      sprintf( strPath, "Cliff-walk pathing, without rocks" );
    } break;

    case PATH_GROUND_WITHROCKS_NORESOURCES:
    {
      sprintf( strPath, "Ground pathing, w/ rocks, no resouces" );
    } break;

    case PATH_BUILDABLE:
    {
      sprintf( strPath, "Buildable pathing" );
    } break;

    case PATH_BUILDABLE_MAIN:
    {
      sprintf( strPath, "Main building pathing" );
    } break;

    default:
      sprintf( strPath, "UNKNOWN PATHING TYPE?" );
  }

  char title[2*FILENAME_LENGTH];
  sprintf( title,
           "%s - %s",
           mapName.data(),
           strPath );

  plotText( title,
            18,          // font size
            false,       // centered,
            20, iTop+20, // bottom-left
            0.0f,        // angle
            getColor( "defaultTxtFg" ),
            getColor( "defaultTxtBg" ) );

  renderPathing( t );
  renderTerrain();
  renderStartLocs();
  renderFooter();
  img->close();
}


void SC2Map::renderImageBases() {

  resetPNGWriter( "-bases",
                  20, 20,
                  58,
                  iFooterHeight );

  char title[2*FILENAME_LENGTH];
  sprintf( title,
           "%s - Bases identified (tot. resources, avg. openness)",
           mapName.data() );

  plotText( title,
            18,          // font size
            false,       // centered,
            20, iTop+20, // bottom-left
            0.0f,        // angle
            getColor( "defaultTxtFg" ),
            getColor( "defaultTxtBg" ) );

  renderOpenness( PATH_GROUND_WITHROCKS );
  renderTerrain();
  renderDestructs();
  renderLoSBs();
  renderResources();
  renderBasesDebug();
  renderFooter();
  img->close();
}


void SC2Map::renderImagesShortestPaths() {
  for( list<StartLoc*>::const_iterator itr1 = startLocs.begin();
       itr1 != startLocs.end();
       ++itr1 )
  {
    StartLoc* sl1 = *itr1;

    list<StartLoc*>::const_iterator itr2 = itr1;
    ++itr2;
    for( ;
         itr2 != startLocs.end();
         ++itr2 )
    {
      StartLoc* sl2 = *itr2;

      char filename[FILENAME_LENGTH];
      sprintf( filename, "-shortestPaths-%d-%d", sl1->idNum, sl2->idNum );

      char title[2*FILENAME_LENGTH];
      sprintf( title,
               "%s - Shortest paths, %s to %s",
               mapName.data(),
               sl1->name,
               sl2->name );

      renderImageShortestPaths( filename,
                                title,
                                &(sl1->loc),
                                NULL,
                                &(sl2->loc),
                                NULL );

      if( sl1->natBase != NULL &&
          sl2->natBase != NULL &&
          sl1->natBase != sl2->natBase )
      {
        sprintf( filename, "-shortestPaths-%d-%d-nats", sl1->idNum, sl2->idNum );

        sprintf( title,
                 "%s - Shortest paths, naturals, %s to %s",
                 mapName.data(),
                 sl1->name,
                 sl2->name );

        renderImageShortestPaths( filename,
                                  title,
                                  NULL,
                                  sl1->natBase,
                                  NULL,
                                  sl2->natBase );
      }
    }
  }
}


// one of b0, p0 is NULL, other non-NULL, same for p1, b1
void SC2Map::renderImageShortestPaths( char*  filename,
                                       char*  title,
                                       point* p0,
                                       Base*  b0,
                                       point* p1,
                                       Base*  b1 ) {
  if( (p0 == NULL && b0 == NULL) ||
      (p0 != NULL && b0 != NULL) ||
      (p1 == NULL && b1 == NULL) ||
      (p1 != NULL && b1 != NULL) )
  {
    printError( "Inputs to renderImageShortestPaths are invalid.\n" );
    exit( -1 );
  }

  resetPNGWriter( filename,
                  20, 20, // borders left right
                  86,     // border top
                  iFooterHeight );   // border bottom

  plotText( title,
            18,          // font size
            false,       // centered,
            20, iTop+48, // bottom-left
            0.0f,        // angle
            getColor( "defaultTxtFg" ),
            getColor( "defaultTxtBg" ) );

  int textOffset = 20;

  char path[32];

  sprintf( path,
           "by Air  " );
  plotText( path,
            18,                       // font size
            false,                    // centered,
            20 + textOffset, iTop+20, // bottom-left
            0.0f,                     // angle
            getColor( "shortestPathAir" ),
            getColor( "defaultTxtBg" ) );

  textOffset += getTextWidth( path, 18 );

  sprintf( path,
           "by Ground  " );
  plotText( path,
            18,                       // font size
            false,                    // centered,
            20 + textOffset, iTop+20, // bottom-left
            0.0f,                     // angle
            getColor( "shortestPathGround" ),
            getColor( "defaultTxtBg" ) );

  textOffset += getTextWidth( path, 18 );

  sprintf( path,
           "by Cliff-Walk" );
  plotText( path,
            18,                       // font size
            false,                    // centered,
            20 + textOffset, iTop+20, // bottom-left
            0.0f,                     // angle
            getColor( "shortestPathCWalk" ),
            getColor( "defaultTxtBg" ) );

  renderTerrain();
  renderPathing( PATH_GROUND_WITHROCKS );
  renderDestructs();
  renderLoSBs();
  renderResources();

  if( p0 != NULL && p1 != NULL )
  {
    plotAirPath     ( p0, p1,                        getColor( "shortestPathAir"    ), 0.25f );
    plotShortestPath( p0, p1, PATH_GROUND_WITHROCKS, getColor( "shortestPathGround" ), 0.50f, dNoOverride );
    plotShortestPath( p0, p1, PATH_CWALK_WITHROCKS,  getColor( "shortestPathCWalk"  ), 0.75f, dNoOverride );
  }
  else if( p0 != NULL && b1 != NULL )
  {
    plotAirPath     ( p0, &(b1->loc),                getColor( "shortestPathAir"    ), 0.25f );
    plotShortestPath( p0, b1, PATH_GROUND_WITHROCKS, getColor( "shortestPathGround" ), 0.50f );
    plotShortestPath( p0, b1, PATH_CWALK_WITHROCKS,  getColor( "shortestPathCWalk"  ), 0.75f );
  }
  else if( b0 != NULL && p1 != NULL )
  {
    plotAirPath     ( p1, &(b0->loc),                getColor( "shortestPathAir"    ), 0.25f );
    plotShortestPath( p1, b0, PATH_GROUND_WITHROCKS, getColor( "shortestPathGround" ), 0.50f );
    plotShortestPath( p1, b0, PATH_CWALK_WITHROCKS,  getColor( "shortestPathCWalk"  ), 0.75f );
  }
  else
  {
    plotAirPath     ( &(b0->loc), &(b1->loc),        getColor( "shortestPathAir"    ), 0.25f );
    plotShortestPath( b0, b1, PATH_GROUND_WITHROCKS, getColor( "shortestPathGround" ), 0.50f );
    plotShortestPath( b0, b1, PATH_CWALK_WITHROCKS,  getColor( "shortestPathCWalk"  ), 0.75f );
  }

  renderStartLocs();
  renderFooter();
  img->close();
}


void SC2Map::plotAirPath( point* p0, point* p1,
                          Color* color,
                          float labelPlacement )
{
  plotLine( ix2png( p0->ix ),
            iy2png( p0->iy ),
            ix2png( p1->ix ),
            iy2png( p1->iy ),
            2.0f,
            color );

  float dTotal = getShortestAirDistance( p0, p1 );

  float dix = (float)(p1->ix - p0->ix);
  float diy = (float)(p1->iy - p0->iy);

  int ixLabel = p0->ix + (int)(dix*labelPlacement);
  int iyLabel = p0->iy + (int)(diy*labelPlacement);

  char strDistance[512];
  sprintf( strDistance, "%.1f", dTotal );

  plotText( strDistance, 18,
            true,               // centered
            ix2png( ixLabel ),
            iy2png( iyLabel ),
            0.0f,               // angle
            color,
            getColor( "defaultTxtBg" ) );
}



void SC2Map::plotShortestPath( point* p, Base* b0, PathType t,
                               Color* color,
                               float labelPlacement )
{
  Node* u = getPathNode( p, t );
  float d = getShortestPathDistance   ( u, b0, t );
  Node* v = getShortestPathPredecessor( u, b0, t );

  // plot just from the base to the v, use
  // normal point-to-point to plot the rest
  plotLine( ix2png( v ->loc.ix ), iy2png( v ->loc.iy ),
            ix2png( b0->loc.ix ), iy2png( b0->loc.iy ),
            2.0f,
            color );

  plotShortestPath( p, &(v->loc), t,
                    color,
                    labelPlacement,
                    d );
}


void SC2Map::plotShortestPath( Base* b0, Base* b1, PathType t,
                               Color* color,
                               float labelPlacement )
{
  Node* u;
  Node* v;

  getShortestPathPredecessors( b0, b1, t, &u, &v );

  float d = getShortestPathDistance( b0, b1, t );

  // plot just from the base to the v, use
  // normal point-to-point to plot the rest
  plotLine( ix2png( u ->loc.ix ), iy2png( u ->loc.iy ),
            ix2png( b0->loc.ix ), iy2png( b0->loc.iy ),
            2.0f,
            color );

  plotLine( ix2png( v ->loc.ix ), iy2png( v ->loc.iy ),
            ix2png( b1->loc.ix ), iy2png( b1->loc.iy ),
            2.0f,
            color );

  plotShortestPath( &(u->loc), &(v->loc), t,
                    color,
                    labelPlacement,
                    d );
}


void SC2Map::plotShortestPath( point* p0, point* p1, PathType t,
                               Color* color,
                               float labelPlacement,
                               float dOverride )
{
  Node* src = getPathNode( p0, t );
  Node* u   = getPathNode( p1, t );
  Node* v   = getShortestPathPredecessor( src, u, t );

  bool positionedLabel = false;

  float dTotal = getShortestPathDistance( src, u, t );


  int ixLabel;
  int iyLabel;

  // give some default position for the no-path case
  // but based on the labelPlacement so ground and
  // cliffwalk infinity values do not overlap!
  if( v == NULL )
  {
    float dix = (float)(p1->ix - p0->ix);
    float diy = (float)(p1->iy - p0->iy);

    ixLabel = p0->ix + (int)(dix*labelPlacement);
    iyLabel = p0->iy + (int)(diy*labelPlacement);
  }

  // otherwise the label will get positioned on the path
  while( v != NULL )
  {
    plotLine( ix2png( u->loc.ix ), iy2png( u->loc.iy ),
              ix2png( v->loc.ix ), iy2png( v->loc.iy ),
              2.0f,
              color );
    u = v;
    v = getShortestPathPredecessor( src, u, t );

    float d = getShortestPathDistance( src, u, t );
    if( !positionedLabel && d < dTotal * labelPlacement )
    {
      ixLabel = u->loc.ix;
      iyLabel = u->loc.iy;
      positionedLabel = true;
    }
  }

  char strDistance[512];

  if( effectivelyInfinity( dTotal ) ) {
    sprintf( strDistance, "No path" );

  } else if ( dOverride > dNoOverride ) {
    sprintf( strDistance, "%.1f", dOverride );

  } else {
    sprintf( strDistance, "%.1f", dTotal );
  }

  plotText( strDistance, 18,
            true,               // centered
            ix2png( ixLabel ),
            iy2png( iyLabel ),
            0.0f,               // angle
            color,
            getColor( "defaultTxtBg" ) );
}



void SC2Map::renderImageOpenness()
{
  resetPNGWriter( "-openness",
                  20, 20, // borders left right
                  86,     // border top
                  iFooterHeight );   // border bottom

  char title[2*FILENAME_LENGTH];
  sprintf( title,
           "%s - Openness, by ground pathing with rocks",
           mapName.data() );

  plotText( title,
            18,          // font size
            false,       // centered,
            20, iTop+48, // bottom-left
            0.0f,        // angle
            getColor( "defaultTxtFg" ),
            getColor( "defaultTxtBg" ) );

  Color color;

  for( int i = 0; i < 255; ++i )
  {
    float fi       = (float)i;
    float openness = getfConstant( "opennessRenderMax" ) * fi / 200.0f;

    openness2color( openness, &color );

    img->line( 30+i, iTop+18,
               30+i, iTop+40,
               color.r, color.g, color.b );
  }

  char num[32];

  openness2color( 0.0f, &color );
  sprintf( num, "%.1f", 0.0f );
  plotText( num,
            16,          // font size
            true,        // centered,
            50, iTop+30, //
            0.0f,        // angle
            &color,
            getColor( "defaultTxtBg" ) );

  openness2color( getfConstant( "opennessRenderMax" )*0.5f, &color );
  sprintf( num, "%.1f", getfConstant( "opennessRenderMax" )*0.5f );
  plotText( num,
            16,           // font size
            true,         // centered,
            150, iTop+30, //
            0.0f,         // angle
            &color,
            getColor( "defaultTxtBg" ) );

  openness2color( getfConstant( "opennessRenderMax" ), &color );
  sprintf( num, "%.1f+", getfConstant( "opennessRenderMax" ) );
  plotText( num,
            16,           // font size
            true,         // centered,
            250, iTop+30, //
            0.0f,         // angle
            &color,
            getColor( "defaultTxtBg" ) );

  renderTerrain();
  renderOpenness( PATH_GROUND_WITHROCKS );
  renderDestructs();
  renderLoSBs();
  renderResources();
  renderStartLocs();
  renderFooter();
  img->close();
}


void SC2Map::renderOpenness( PathType t )
{
  for( int pci = 0; pci < cxDimPlayable; ++pci )
  {
    for( int pcj = 0; pcj < cyDimPlayable; ++pcj )
    {
      point c;
      c.pcSet( pci, pcj );
      plotOpenness( &c, t );
    }
  }
}


void SC2Map::plotOpenness( point* c, PathType t )
{
  Color color;

  if( !checkHasOpenness( c, t ) ) {
    color.r = 0.0f;
    color.g = 0.0f;
    color.b = 0.0f;

  } else {

    float openness = getOpenness( c, t );
    //openness2color( openness, &color );
    
    string colorBaseName = "openness";
    
    // iGrok's
    //float n = openness / getfConstant( "opennessRenderMax" );
    
    
    switch( getHeightCell( c ) ) {
    
      case 0x0:
      case 0x1: {
        //Color* tint = getColor( "opennessTerrainLowTint" );    
        //color.r += tint->r;
        //color.g += tint->g;
        //color.b += tint->b;
        //alterSaturation( getfConstant( "opennessElevLowSaturation" ), &color );
        //mixWith( &color, getColor( "opennessTerrainLowTint" ) );
        //color.r = 32.0f + 160.0f * n;
        //color.g = 32.0f +  96.0f * n;
        //color.b = 32.0f +  96.0f * n;
        colorBaseName.append( "Low" );
      } break;

      case 0x2: {
        //Color* tint = getColor( "opennessTerrainLowTint" );    
        //color.r += tint->r;
        //color.g += tint->g;
        //color.b += tint->b;
        //alterSaturation( getfConstant( "opennessElevLowSaturation" ), &color );
        //color.r = 32.0f +  96.0f * n;
        //color.g = 32.0f + 160.0f * n;
        //color.b = 32.0f +  96.0f * n;
        colorBaseName.append( "Mid" );
      } break;

      case 0x3: {
        //Color* tint = getColor( "opennessTerrainHighTint" );    
        //color.r += tint->r;
        //color.g += tint->g;
        //color.b += tint->b;
        //alterSaturation( getfConstant( "opennessElevHighSaturation" ), &color );
        //mixWith( &color, getColor( "opennessTerrainHighTint" ) );
        //color.r = 32.0f +  96.0f * n;
        //color.g = 32.0f +  96.0f * n;
        //color.b = 32.0f + 160.0f * n;
        colorBaseName.append( "High" );
      } break;
    }
    
    gradient( openness / getfConstant( "opennessRenderMax" ),
              getiConstant( "numOpennessGradientColors" ),
              &colorBaseName,
              &color );
  }

  //color.r /= 256.0f;
  //color.g /= 256.0f;
  //color.b /= 256.0f;
  
  
  
  
  plotCellPoint( c, &color );
}


void SC2Map::openness2color( float opennessIn,
                             Color* colorOut )
{
  /*
  gradient( opennessIn / getfConstant( "opennessRenderMax" ),
            getColor( "opennessLow"  ),
            getColor( "opennessMid1" ),
            getColor( "opennessMid2" ),
            getColor( "opennessHigh" ),
            colorOut );
  */
}



void SC2Map::renderImageSummary() {

  resetPNGWriter( "-summary",
                  20, 20, // borders left right
                  86,     // border top
                  iFooterHeight );   // border bottom

  char title[2*FILENAME_LENGTH];
  sprintf( title,
           "%s - Summary",
           mapName.data() );

  plotText( title,
            18,          // font size
            false,       // centered,
            20, iTop+48, // bottom-left
            0.0f,        // angle
            getColor( "defaultTxtFg" ),
            getColor( "defaultTxtBg" ) );

  sprintf( title,
           "Avg. Openness: %.2f,  Watchtower Coverage: %.1f%%",
           opennessAvg[PATH_GROUND_WITHROCKS],
           100.0f * watchtowerCoverage );

  plotText( title,
            18,          // font size
            false,       // centered,
            20, iTop+24, // bottom-left
            0.0f,        // angle
            getColor( "defaultTxtFg" ),
            getColor( "defaultTxtBg" ) );


  renderOpenness( PATH_GROUND_WITHROCKS );
  //renderTerrain();
  renderResources();
  renderDestructs();
  renderLoSBs();
  renderChokes();
  renderBases();
  renderSpaceInMain();
  renderWatchtowers();
  renderFooter();
  img->close();
}


void SC2Map::renderImagesInfluenceHeatMap()
{
  for( list<StartLoc*>::const_iterator itr1 = startLocs.begin();
       itr1 != startLocs.end();
       ++itr1 )
  {
    StartLoc* sl1 = *itr1;

    list<StartLoc*>::const_iterator itr2 = itr1;
    ++itr2;
    for( ;
         itr2 != startLocs.end();
         ++itr2 )
    {
      StartLoc* sl2 = *itr2;

      renderImageInfluenceHeatMap( sl1, sl2 );
    }
  }
}


void SC2Map::renderImageInfluenceHeatMap( StartLoc* sl1,
                                          StartLoc* sl2 )
{
  char filename[FILENAME_LENGTH];
  sprintf( filename, "-influence-heatmap-%d-%d", sl1->idNum, sl2->idNum );

  resetPNGWriter( filename,
                  20, 20,       // borders: left, right
                  58,          // border: top
                  iFooterHeight // border: bottom
                  );

  int textOffset = 20;

  char text[128];


  sprintf( text,
           "%s - Influence Heat Map, ",
           mapName.data() );

  plotText( text,
            18,          // font size
            false,       // centered,
            textOffset, iTop+20, // bottom-left
            0.0f,        // angle
            getColor( "defaultTxtFg" ),
            getColor( "defaultTxtBg" ) );

  textOffset += getTextWidth( text, 18 );


  sprintf( text,
           "%s",
           sl1->name );

  plotText( text,
            18,          // font size
            false,       // centered,
            textOffset, iTop+20, // bottom-left
            0.0f,        // angle
            getColor( "influenceLoc1" ),
            getColor( "defaultTxtBg" ) );

  textOffset += getTextWidth( text, 18 );


  sprintf( text, " vs " );

  plotText( text,
            18,          // font size
            false,       // centered,
            textOffset, iTop+20, // bottom-left
            0.0f,        // angle
            getColor( "defaultTxtFg" ),
            getColor( "defaultTxtBg" ) );

  textOffset += getTextWidth( text, 18 );


  sprintf( text,
           "%s",
           sl2->name );

  plotText( text,
            18,          // font size
            false,       // centered,
            textOffset, iTop+20, // bottom-left
            0.0f,        // angle
            getColor( "influenceLoc2" ),
            getColor( "defaultTxtBg" ) );

  renderTerrain();
  renderInfluenceHeatMap( sl1, sl2 );
  renderDestructs();
  renderLoSBs();
  renderResources();
  renderInfluence( sl1, sl2 );
  plotStartLoc( sl1, getColor( "influenceLoc1" ) );
  plotStartLoc( sl2, getColor( "influenceLoc2" ) );
  renderFooter();
  img->close();
}


void SC2Map::renderInfluenceHeatMap( StartLoc* sl1,
                                     StartLoc* sl2 )
{
  for( int pci = 0; pci < cxDimPlayable; ++pci )
  {
    for( int pcj = 0; pcj < cyDimPlayable; ++pcj )
    {
      point c;
      c.pcSet( pci, pcj );
      plotInfluenceHeatMap( &c, sl1, sl2 );
    }
  }
}


void SC2Map::plotInfluenceHeatMap( point*    c,
                                   StartLoc* sl1,
                                   StartLoc* sl2 )
{
  float d1 = weightedInfluenceDistance( sl1, NULL, c );
  float d2 = weightedInfluenceDistance( sl2, NULL, c );

  float dTotal   = d1 + d2;
  float dAverage = 0.5f * dTotal;
  float pNeutral = 0.5f;

  float pInfl = pNeutral + ((dAverage - d1) / dTotal);

  Color color;

  if( !getPathing( c, PATH_GROUND_NOROCKS ) )
  {
    color.r = 0.0f;
    color.g = 0.0f;
    color.b = 0.0f;
  } else {

    if( getiConstant( "influenceHeatMapBlendMode" ) == 2 ) {
      gradientNoBlend( pInfl,
                       getiConstant( "influenceHeatMapRepeat" ),
                       getColor( "influence1" ),
                       getColor( "influence2" ),
                       getColor( "influence3" ),
                       &color );
    } else {
      /*
      gradient( pInfl,
                getiConstant( "influenceHeatMapRepeat" ),
                getColor( "influence1" ),
                getColor( "influence2" ),
                getColor( "influence3" ),
                &color );
      */
    }
  }

  plotCellPoint( c, &color );
}



void SC2Map::renderImagesInfluence()
{
  for( list<StartLoc*>::const_iterator itr1 = startLocs.begin();
       itr1 != startLocs.end();
       ++itr1 )
  {
    StartLoc* sl1 = *itr1;

    list<StartLoc*>::const_iterator itr2 = itr1;
    ++itr2;
    for( ;
         itr2 != startLocs.end();
         ++itr2 )
    {
      StartLoc* sl2 = *itr2;

      renderImageInfluence( sl1, sl2 );
    }
  }
}

void SC2Map::renderImageInfluence( StartLoc* sl1,
                                   StartLoc* sl2 )
{
  char filename[FILENAME_LENGTH];
  sprintf( filename, "-influence-%d-%d", sl1->idNum, sl2->idNum );

  resetPNGWriter( filename,
                  20, 20,       // borders: left, right
                  126,          // border: top
                  iFooterHeight // border: bottom
                  );

  int textOffset = 20;

  char text[128];


  sprintf( text,
           "%s - Influence, ",
           mapName.data() );

  plotText( text,
            18,          // font size
            false,       // centered,
            textOffset, iTop+76, // bottom-left
            0.0f,        // angle
            getColor( "defaultTxtFg" ),
            getColor( "defaultTxtBg" ) );

  textOffset += getTextWidth( text, 18 );


  sprintf( text,
           "%s",
           sl1->name );

  plotText( text,
            18,          // font size
            false,       // centered,
            textOffset, iTop+76, // bottom-left
            0.0f,        // angle
            getColor( "influenceLoc1" ),
            getColor( "defaultTxtBg" ) );

  textOffset += getTextWidth( text, 18 );


  sprintf( text, " vs " );

  plotText( text,
            18,          // font size
            false,       // centered,
            textOffset, iTop+76, // bottom-left
            0.0f,        // angle
            getColor( "defaultTxtFg" ),
            getColor( "defaultTxtBg" ) );

  textOffset += getTextWidth( text, 18 );


  sprintf( text,
           "%s",
           sl2->name );

  plotText( text,
            18,          // font size
            false,       // centered,
            textOffset, iTop+76, // bottom-left
            0.0f,        // angle
            getColor( "influenceLoc2" ),
            getColor( "defaultTxtBg" ) );


  sprintf( text,
           "Positional Balance, by resources: %s(%.1f%%) vs %s(%.1f%%)",
           sl1->name,
           sl1->sl2percentBalancedByResources[sl2],
           sl2->name,
           sl2->sl2percentBalancedByResources[sl1] );

  plotText( text,
            18,          // font size
            false,       // centered,
            20, iTop+48, // bottom-left
            0.0f,        // angle
            getColor( "defaultTxtFg" ),
            getColor( "defaultTxtBg" ) );


  sprintf( text,
           "Positional Balance, by openness: %s(%.1f%%) vs %s(%.1f%%)",
           sl1->name,
           sl1->sl2percentBalancedByOpenness[sl2],
           sl2->name,
           sl2->sl2percentBalancedByOpenness[sl1] );

  plotText( text,
            18,          // font size
            false,       // centered,
            20, iTop+20, // bottom-left
            0.0f,        // angle
            getColor( "defaultTxtFg" ),
            getColor( "defaultTxtBg" ) );


  renderTerrain();
  renderOpenness( PATH_GROUND_WITHROCKS );
  renderDestructs();
  renderLoSBs();
  renderResources();
  renderInfluence( sl1, sl2 );
  plotStartLoc( sl1, getColor( "influenceLoc1" ) );
  plotStartLoc( sl2, getColor( "influenceLoc2" ) );
  renderFooter();
  img->close();
}


void SC2Map::renderInfluence( StartLoc* sl1, StartLoc* sl2 ) {
  for( list<Base*>::const_iterator itr = bases.begin();
       itr != bases.end();
       ++itr )
  {
    Base* b = *itr;

    map<StartLoc*, float>* innerMap = b->sl1vsl2_influence[sl1];
    float infl1 = (*innerMap)[sl2];

    innerMap = b->sl1vsl2_influence[sl2];
    float infl2 = (*innerMap)[sl1];

    char strInfl[64];

    if( infl1 > infl2 )
    {
      sprintf( strInfl,
               "%.1f%%",
               infl1 );

      plotText( strInfl,
                18,          // font size
                true,       // centered,
                ix2png( b->loc.ix ), iy2png( b->loc.iy ),
                0.0f,        // angle
                getColor( "influenceLoc1" ),
                getColor( "defaultTxtBg" ) );
    } else {
      sprintf( strInfl,
               "%.1f%%",
               infl2 );

      plotText( strInfl,
                18,          // font size
                true,       // centered,
                ix2png( b->loc.ix ), iy2png( b->loc.iy ),
                0.0f,        // angle
                getColor( "influenceLoc2" ),
                getColor( "defaultTxtBg" ) );
    }
  }
}





void SC2Map::renderTerrain() {
  for( int pti = 0; pti < txDimPlayable; ++pti )
  {
    for( int ptj = 0; ptj < tyDimPlayable; ++ptj )
    {
      point t;
      t.ptSet( pti, ptj );
      plotTerrain( &t );
    }
  }
}
int iTerrain0IconPoints[] = {
  //1, 1, 2, 2, 3, 3, 1, 3, 3, 1,
  2, 2,
};
int iTerrain1IconPoints[] = {
  //1, 1, 2, 1, 3, 1, 2, 2, 2, 3,
  1, 1, 2, 2, 3, 3, 1, 3, 3, 1,
};
int iTerrain2IconPoints[] = {
  1, 1, 1, 2, 2, 1, 2, 2,
};
int iTerrain3IconPoints[] = {
  1, 2, 2, 3, 3, 2, 2, 1, 2, 2,
};
void SC2Map::plotTerrain( point* t ) {

  switch( getHeight( t ) ) {
  
    case 0x0: {
      return;
      //plotTerrainPoint( t, 
      //                  iTerrain0IconPoints, getArrLength( iTerrain0IconPoints ), 
      //                  getColor( "terrainElev0" ) 
      //                );
    } break;
    
    case 0x1: {
      plotTerrainPoint( t, 
                        iTerrain1IconPoints, getArrLength( iTerrain1IconPoints ),
                        getColor( "terrainElev1" ) );
    } break;
    
    case 0x2: {
      return;
      //plotTerrainPoint( t, 
      //                  iTerrain2IconPoints, getArrLength( iTerrain2IconPoints ),
      //                  getColor( "terrainElev2" ) );
    } break;
    
    case 0x3: {
      plotTerrainPoint( t, 
                        iTerrain3IconPoints, getArrLength( iTerrain3IconPoints ),
                        getColor( "terrainElev3" ) );
    } break;
  }  
}
void SC2Map::plotTerrainPoint( point* t, 
                               int* iPoints, int numPoints,
                               Color* color ) {
                               
  // get the bottom-left corner of the cell
  // in output PNG pixels
  int x0 = ix2png( t->ix - iDimC/2 );
  int y0 = iy2png( t->iy - iDimC/2 );

  for( int i = 0; i < numPoints; i = i + 2 ) {
    img->plot( x0 + iPoints[i], 
               y0 + iPoints[i + 1],
               color->r, color->g, color->b );
  }
  
  /*
  img->filledsquare( x0 + 2,
                     y0 + 2,
                     x0 + 3,
                     y0 + 3,
                     color->r, color->g, color->b
                   );
  */
}




void SC2Map::renderPathing( PathType t )
{
  for( int pci = 0; pci < cxDimPlayable; ++pci )
  {
    for( int pcj = 0; pcj < cyDimPlayable; ++pcj )
    {
      point c;
      c.pcSet( pci, pcj );
      plotPathing( &c, t );
    }
  }
}

void SC2Map::plotPathing( point* c, PathType t )
{
  Color* color;

  if( getPathing( c, t ) )
  {
    color = getColor( "pathingClear" );
  } else {
    color = getColor( "pathingBlocked" );
  }

  plotCellPoint( c, color );
}



void SC2Map::renderDestructs() {
  for( list<Destruct*>::const_iterator itr = destructs.begin();
       itr != destructs.end();
       ++itr )
  {
    Destruct* destruct = *itr;
    plotDestruct( &(destruct->loc) );
  }
}
void SC2Map::plotDestruct( point* p ) {
  int x0 = ix2png( p->ix - iDimT/2 );
  int y0 = iy2png( p->iy - iDimT/2 );

  Color* color = getColor( "destruct" );

  img->filledsquare( x0,
                     y0,
                     x0 + iDimT - 1,
                     y0 + iDimT - 1,
                     color->r, color->g, color->b
                   );
}


void SC2Map::renderLoSBs() {
  for( list<LoSB*>::const_iterator itr = losbs.begin();
       itr != losbs.end();
       ++itr )
  {
    LoSB* losb = *itr;
    plotLoSB( &(losb->loc) );
  }
}
void SC2Map::plotLoSB( point* p ) {
  int x0 = ix2png( p->ix - iDimT/2 );
  int y0 = iy2png( p->iy - iDimT/2 );

  Color* color = getColor( "LoSB" );

  img->line( x0,
             y0,
             x0 + iDimT - 1,
             y0 + iDimT - 1,
             color->r, color->g, color->b
           );

  img->line( x0,
             y0 + 3,
             x0 + iDimT - 1 - 3,
             y0 + iDimT - 1,
             color->r, color->g, color->b
           );

  img->line( x0,
             y0 + 6,
             x0 + iDimT - 1 - 6,
             y0 + iDimT - 1,
             color->r, color->g, color->b
           );

  img->line( x0 + 3,
             y0,
             x0 + iDimT - 1,
             y0 + iDimT - 1 - 3,
             color->r, color->g, color->b
           );

  img->line( x0 + 6,
             y0,
             x0 + iDimT - 1,
             y0 + iDimT - 1 - 6,
             color->r, color->g, color->b
           );
}


void SC2Map::renderChokes() {
  for( list<StartLoc*>::const_iterator itr = startLocs.begin();
       itr != startLocs.end();
       ++itr )
  {
    StartLoc* sl = *itr;

    if( sl->mainChoke.mx > 0.0f )
    {
      plotChoke( &(sl->mainChoke),
                 (char*)"Main Choke",
                 getColor( "mainChoke" ) );
    }
  }
}
void SC2Map::plotChoke( point* p,
                        char*  text,
                        Color* color ) {
  int x0 = ix2png( p->ix - iDimT/2 );
  int y0 = iy2png( p->iy - iDimT/2 );

  plotText( text,
            12,         // font size
            true,       // centered,
            x0, y0,
            0.0f,        // angle
            color,
            getColor( "defaultTxtBg" ) );
}



void SC2Map::renderResources() {
  for( list<Resource*>::const_iterator itr = resources.begin();
       itr != resources.end();
       ++itr )
  {
    Resource* r = *itr;
    switch( r->type )
    {
      case MINERALS:
        plotMineralField( &(r->loc), false );
        break;

      case MINERALS_HY:
        plotMineralField( &(r->loc), true );
        break;

      case VESPENEGAS:
        plotGeyser( &(r->loc), false );
        break;
      
      case VESPENEGAS_HY:
        plotGeyser( &(r->loc), true );
        break;

      default:
        printError( "Unknown resource type.\n" );
        exit( -1 );
    }
  }
}
void SC2Map::plotMineralField( point* p, bool highYield ) {
  Color* color;

  if( highYield ) {
    color = getColor( "HYMinerals" );
  } else {
    color = getColor( "regMinerals" );
  }

  int x0 = ix2png( p->ix - iDimT   );
  int y0 = iy2png( p->iy - iDimT/2 );

  img->filledsquare( x0,
                     y0,
                     x0 + 2*iDimT - 1,
                     y0 +   iDimT - 1,
                     color->r, color->g, color->b
                   );
}
void SC2Map::plotGeyser( point* p, bool highYield ) {
  Color* color;

  if( highYield ) {
    color = getColor( "HYGeyser" );
  } else {
    color = getColor( "regGeyser" );
  }

  int x0 = ix2png( p->ix - 3*(iDimT/2) );
  int y0 = iy2png( p->iy - 3*(iDimT/2) );

  img->filledsquare( x0,
                     y0,
                     x0 + 3*iDimT - 1,
                     y0 + 3*iDimT - 1,
                     color->r, color->g, color->b
                   );
}



void SC2Map::renderWatchtowers()
{
  for( list<Watchtower*>::const_iterator itr = watchtowers.begin();
       itr != watchtowers.end();
       ++itr )
  {
    plotWatchtower( *itr );
  }
}


// ib is i for image units, but the b is for bitmap which
// means the y-axis is zero at the top and goes positive down
// the image
int ibTowerIconPoints[] = {
  5, 4, 6, 4, 7, 4, 8, 4, 9, 4, 10, 4,
  3, 5, 4, 5, 5, 5, 6, 5, 7, 5, 8, 5, 9, 5, 10, 5, 11, 5, 12, 5,
  2, 6, 3, 6, 4, 6, 5, 6, 6, 6, 7, 6, 8, 6, 9, 6, 10, 6, 11, 6, 12, 6, 13, 6,
  1, 7, 2, 7, 3, 7,   6, 7, 7, 7, 8, 7, 9, 7,   12, 7, 13, 7, 14, 7,
  1, 8, 2, 8,   6, 8, 7, 8, 8, 8, 9, 8,   13, 8, 14, 8,
  2, 9, 3, 9,   7, 9, 8, 9,   12, 9, 13, 9,
  3, 10, 4, 10, 5, 10,   10, 10, 11, 10, 12, 10,
  5, 11, 6, 11, 7, 11, 8, 11, 9, 11, 10, 11,
};


void SC2Map::plotWatchtower( Watchtower* wt ) {

  // draw an ellipse showing the radius in cells
  Color* color = getColor( "watchTowerRadius" );
  img->circle( ix2png( wt->loc.ix ),
               iy2png( wt->loc.iy ),
               iDimT * (int)wt->range,
               color->r, color->g, color->b );

  int x0 = ix2png( wt->loc.ix - iDimT );
  int y0 = iy2png( wt->loc.iy - iDimT );

  color = getColor( "watchTowerBg" );
  img->filledsquare( x0,
                     y0,
                     x0 + 2*iDimT - 1,
                     y0 + 2*iDimT - 1,
                     color->r, color->g, color->b
                   );

  color = getColor( "watchTowerFg" );
  //img->filledsquare( x0,
  //                   y0,
  //                   x0 + 2*iDimT - 1,
  //                   y0 + 2*iDimT - 1,
  //                   color->r, color->g, color->b
  //                 );
  
  for( int i = 0; i < getArrLength( ibTowerIconPoints ); i = i + 2 ) {
    img->plot( x0 +               ibTowerIconPoints[i], 
               y0 + 2*iDimT - 1 - ibTowerIconPoints[i + 1],
               color->r, color->g, color->b );
  }
}




void SC2Map::renderStartLocs()
{
  for( list<StartLoc*>::const_iterator itr = startLocs.begin();
       itr != startLocs.end();
       ++itr )
  {
    plotStartLoc( *itr, getColor( "startLocation" ) );
  }
}

void SC2Map::plotStartLoc( StartLoc* sl, Color* color )
{
  int x0 = ix2png( sl->loc.ix - 5*(iDimT/2) );
  int y0 = iy2png( sl->loc.iy - 5*(iDimT/2) );

  img->filledsquare( x0,
                     y0,
                     x0 + 5*iDimT - 1,
                     y0 + 5*iDimT - 1,
                     1.0f, 1.0f, 1.0f
                   );

  plotText( sl->name, 18,
            true,               // centered
            ix2png( sl->loc.ix ),
            iy2png( sl->loc.iy ),
            0.0f,               // angle
            color,
            getColor( "defaultTxtBg" ) );
}








void SC2Map::renderBases() {
  for( list<Base*>::const_iterator itr = bases.begin();
       itr != bases.end();
       ++itr )
  {
    plotBaseInformation( *itr );
  }
}

void SC2Map::renderBasesDebug() {
  for( list<Base*>::const_iterator itr = bases.begin();
       itr != bases.end();
       ++itr )
  {
    plotBaseDebugInformation( *itr );
  }
}



void SC2Map::plotBaseInformation( Base* base ) {

  int icenterx = ix2png( base->loc.ix );
  int icentery = iy2png( base->loc.iy );

  int maxSegments = 9;
  
  char*  texts[maxSegments];
  Color* fores[maxSegments];
  Color* backs[maxSegments];

  for( int i = 0; i < maxSegments; ++i ) {
    texts[i] = new char[50];
  }

  int segment = 0;


  
  if( base->isInMain ) {
    sprintf( texts[segment], "In-Main " );
    fores[segment] = getColor( "defaultTxtFg" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;
  }
  
  
  if( base->islandType == ISLAND ) {
    if( base->numExpo != OTHER_EXPO ) {
      sprintf( texts[segment], "Island " );
    } else {
      sprintf( texts[segment], "Island" );
    }
    fores[segment] = getColor( "baseClass-island" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;
    
  } else if( base->islandType == SEMI_ISLAND ) {
    if( base->numExpo != OTHER_EXPO ) {
      sprintf( texts[segment], "Semi Island " );
    } else {
      sprintf( texts[segment], "Semi Island" );
    }
    fores[segment] = getColor( "baseClass-semiIsland" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;
  }  

  
  if( base->numExpo == MAIN_EXPO && base->sl->spaceInMain > 0 ) {
    float numCCs = ((float)base->sl->spaceInMain) / 25.0f;
    sprintf( texts[segment], "Main: %.1f CCs", numCCs );
    fores[segment] = getColor( "spaceInMain" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;
  
  } else if( base->numExpo == NATURAL_EXPO ) {
    sprintf( texts[segment], "Natural" );
    fores[segment] = getColor( "baseClass-natural" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;  
    
  } else if( base->numExpo == THIRD_EXPO ) {
    sprintf( texts[segment], "Third" );
    fores[segment] = getColor( "baseClass-third" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;    
  }

  plotTextMultiColor( segment,
                      texts,
                      18,
                      true,
                      icenterx, icentery,
                      0.0f,
                      (Color**)fores,
                      (Color**)backs );
  
  
  
  
  icentery -= 22;
  segment = 0;
  
  
  /*
  if( base->totalRegMinerals > 0.0f ||
      base->totalHYMinerals  > 0.0f ) {
    sprintf( texts[segment], "m: " );
    fores[segment] = getColor( "defaultTxtFg" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;
  }
  */
  
  if( base->totalRegMinerals > 0.0f ) {
    sprintf( texts[segment], "%.1fK", base->totalRegMinerals / 1000.0f );
    fores[segment] = getColor( "regMinerals" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;
  }

  if( base->totalRegMinerals > 0.0f &&
      base->totalHYMinerals  > 0.0f ) {
    sprintf( texts[segment], "/" );
    fores[segment] = getColor( "defaultTxtFg" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;
  }

  if( base->totalHYMinerals > 0.0f ) {
    sprintf( texts[segment], "%.1fK", base->totalHYMinerals / 1000.0f );
    fores[segment] = getColor( "HYMinerals" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;
  }
  
  if( base->totalRegMinerals   + base->totalHYMinerals   > 0.0f &&
      base->totalRegVespeneGas + base->totalHYVespeneGas > 0.0f   ) {
    sprintf( texts[segment], ", " );
    fores[segment] = getColor( "defaultTxtFg" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;
  }      

  /*
  if( base->totalRegVespeneGas > 0.0f ||
      base->totalHYVespeneGas  > 0.0f ) {
    sprintf( texts[segment], "g: " );
    fores[segment] = getColor( "defaultTxtFg" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;
  }
  */
  
  if( base->totalRegVespeneGas > 0.0f ) {
    sprintf( texts[segment], "%.1fK", base->totalRegVespeneGas / 1000.0f );
    fores[segment] = getColor( "regGeyser" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;
  }

  if( base->totalRegVespeneGas > 0.0f &&
      base->totalHYVespeneGas  > 0.0f ) {
    sprintf( texts[segment], "/" );
    fores[segment] = getColor( "defaultTxtFg" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;
  }

  if( base->totalHYVespeneGas > 0.0f ) {
    sprintf( texts[segment], "%.1fK", base->totalHYVespeneGas / 1000.0f );
    fores[segment] = getColor( "HYGeyser" );
    backs[segment] = getColor( "defaultTxtBg" );
    ++segment;
  }


  
  plotTextMultiColor( segment,
                      texts,
                      16,
                      true,
                      icenterx, icentery,
                      0.0f,
                      (Color**)fores,
                      (Color**)backs );


                      
  for( int i = 0; i < maxSegments; ++i ) {
    delete texts[i];
  }
}

void SC2Map::renderSpaceInMain() {

}

void SC2Map::plotBaseDebugInformation( Base* base ) {
  int x0 = ix2png( base->loc.ix - (iDimT/2) );
  int y0 = iy2png( base->loc.iy - (iDimT/2) );


  // draw an ellipse showing the openness
  // neighborhood radius in cells
  Color* color = getColor( "debugBaseOpennessNeighborhoodRadius" );
  img->circle( ix2png( base->loc.ix ),
               iy2png( base->loc.iy ),
               iDimT * (int)getfConstant( "baseAvgOpennessNeighborhoodRadius" ),
               color->r, color->g, color->b );


  // point from a base to the start location it "belongs to"
  // in terms of main, nat, and third
  for( list<StartLoc*>::const_iterator itr = startLocs.begin();
       itr != startLocs.end();
       ++itr )
  {
    StartLoc* sl = *itr;

    if( base == sl->mainBase ||
        base == sl->natBase  ||
        base == sl->thirdBase )
    {
      plotArrow( ix2png( sl->loc.ix ), iy2png( sl->loc.iy ),
                 ix2png( base->loc.ix  ), iy2png( base->loc.iy  ),
                 color );
    }
  }


  // draw arrow pointing to resource patches that
  // belong to this base, from the base's center
  color = getColor( "debugBaseArrowsToResources" );
  img->filledsquare( x0,
                     y0,
                     x0 + iDimT - 1,
                     y0 + iDimT - 1,
                     color->r, color->g, color->b
                   );

  for( list<Resource*>::const_iterator itr = base->resources.begin();
       itr != base->resources.end();
       ++itr )
  {
    Resource* r = *itr;

    plotArrow( ix2png( base->loc.ix ), iy2png( base->loc.iy ),
               ix2png( r->loc.ix    ), iy2png( r->loc.iy    ),
               color );
  }
}










void SC2Map::plotCellPoint( point* c, Color* color )
{
  // point looks like, where ## is the
  // bottom-left pixel of the bounding box
  //
  //        t1t1
  //    t1t1t1t1t1t1
  //    t1t1t1t1t1t1
  //  t1t1t1t1t1t1t1t1
  //  t1t1t1t1t1t1t1t1
  //    t1t1t1t1t1t1
  //    t1t1t1t1t1t1
  //  ##    t1t1


  // get the bottom-left corner of the terrain point
  // in output PNG pixels
  int x0 = ix2png( c->ix - iDimT/2 );
  int y0 = iy2png( c->iy - iDimT/2 );


  /*
  // do most of the thing as a rectangle--remember
  // pngwriter plots the inclsive rectangle, so subtract
  // one from the top and right coordinates
  img->filledsquare( x0 + 1,
                     y0 + 1,
                     x0 + iDimT - 2,
                     y0 + iDimT - 2,
                     color->r, color->g, color->b
                   );

  // then plot the 8 pixels that stick out of the
  // four sides of the bigger rectable
  img->plot( x0,             y0 + 3,         color->r, color->g, color->b );
  img->plot( x0,             y0 + 4,         color->r, color->g, color->b );
  img->plot( x0 + iDimT - 1, y0 + 3,         color->r, color->g, color->b );
  img->plot( x0 + iDimT - 1, y0 + 4,         color->r, color->g, color->b );
  img->plot( x0 + 3,         y0,             color->r, color->g, color->b );
  img->plot( x0 + 4,         y0,             color->r, color->g, color->b );
  img->plot( x0 + 3,         y0 + iDimT - 1, color->r, color->g, color->b );
  img->plot( x0 + 4,         y0 + iDimT - 1, color->r, color->g, color->b );
  */

  /*
  img->filledsquare( x0,
                     y0 + 1,
                     x0 + iDimT - 1,
                     y0 + iDimT - 2,
                     color->r, color->g, color->b
                   );

  img->filledsquare( x0 + 1,
                     y0,
                     x0 + iDimT - 2,
                     y0 + iDimT - 1,
                     color->r, color->g, color->b
                   );
  */
  img->filledsquare( x0,
                     y0,
                     x0 + iDimT - 1,
                     y0 + iDimT - 1,
                     color->r, color->g, color->b
                   );
}




void SC2Map::plotArrow( int x0, int y0, int x1, int y1,
                        Color* color )
{
  if( x0 == x1 && y0 == y1 )
  {
    // apparently if you try to plot an arrow from one
    // point to the same point, pngwriter dies silently
    return;
  }

  img->arrow( x0, y0, x1, y1,
              4, 0.4f, // size and angle of arrowhead
              color->r, color->g, color->b );
}



void SC2Map::plotLine( int x0, int y0, int x1, int y1,
                       float thick,
                       Color* color )
{
  ////////////////////////////////////////
  //
  //        x10,y10
  //             .
  //             x1,y1
  //              /| .
  //             .   x11, y11
  //   x00,y00  . ang
  //        .  .
  //        x0,y0
  //            .
  //            x01,y01
  //
  ////////////////////////////////////////

  float ang = atan2( y1-y0, x1-x0 ) + M_PI*0.5f;

  int dx = (int)(thick*cos( ang ));
  int dy = (int)(thick*sin( ang ));

  int x00 = x0 + dx;
  int y00 = y0 + dy;
  int x01 = x0 - dx;
  int y01 = y0 - dy;

  int x10 = x1 + dx;
  int y10 = y1 + dy;
  int x11 = x1 - dx;
  int y11 = y1 - dy;

  plotTri( x00, y00,
           x01, y01,
           x11, y11,
           color );

  plotTri( x00, y00,
           x10, y10,
           x11, y11,
           color );
}



void SC2Map::plotTri( int x1, int y1,
                      int x2, int y2,
                      int x3, int y3,
                      Color* color )
{
  // for some reason it appears sorting the
  // three points by ascending y coordinate
  // prevents nasty visual artifacts

  int xa, ya;
  int xb, yb;
  int xc, yc;

  if( y1 < y2 ) {
    // y1 < y2

    if( y2 < y3 ) {
      // y1 < y2 < y3
      xa = x1; ya = y1;
      xb = x2; yb = y2;
      xc = x3; yc = y3;

    } else {
      // y1 < y2   y3 < y2

      if( y1 < y3 ) {
        // y1 < y3 < y2
        xa = x1; ya = y1;
        xb = x3; yb = y3;
        xc = x2; yc = y2;

      } else {
        // y3 < y1 < y2
        xa = x3; ya = y3;
        xb = x1; yb = y1;
        xc = x2; yc = y2;
      }
    }

  } else {
    // y2 < y1

    if( y1 < y3 ) {
      // y2 < y1 < y3
      xa = x2; ya = y2;
      xb = x1; yb = y1;
      xc = x3; yc = y3;

    } else {
      // y2 < y1   y3 < y1

      if( y2 < y3 ) {
        // y2 < y3 < y1
        xa = x2; ya = y2;
        xb = x3; yb = y3;
        xc = x1; yc = y1;

      } else {
        // y3 < y2 < y1
        xa = x3; ya = y3;
        xb = x2; yb = y2;
        xc = x1; yc = y1;
      }
    }

  }

  img->filledtriangle( xa, ya,
                       xb, yb,
                       xc, yc,
                       color->r, color->g, color->b );
}



void SC2Map::plotText( char* text,
                       int fontsize,
                       bool centered, int ix, int iy,
                       float angle,
                       Color* fore,
                       Color* back
                     )
{
  static char fontface[] = "./FreeSansBold.ttf";

  int x;
  int y;

  if( centered )
  {
    int w = img->get_text_width( fontface, fontsize, text );

    x = ix - w/2;
    y = iy - fontsize/2;

  } else {
    // othewise its just the lower left corner
    x = ix;
    y = iy;
  }

  // make a background of the text with offset plots
  for( int i = -2; i <= 2; ++i )
  {
    for( int j = -2; j <= 2; ++j )
    {
      img->plot_text( fontface, fontsize,
                      x + i, y + j,
                      angle, text,
                      back->r, back->g, back->b );
    }
  }

  // then put foreground down
  img->plot_text( fontface, fontsize,
                  x, y,
                  angle, text,
                  fore->r, fore->g, fore->b );
}


int SC2Map::getTextWidth( char* text, int fontsize )
{
  char fontface[] = "./FreeSansBold.ttf";
  return img->get_text_width( fontface, fontsize, text );
}


void SC2Map::plotTextMultiColor( int numSegments,
                                 char** texts,
                                 int fontsize,
                                 bool centered, int ix, int iy,
                                 float angle,
                                 Color** fores,
                                 Color** backs
                               ) {
                                 
  int iStartingX;
  if( centered ) {
    int widthTotal = 0;
    for( int i = 0; i < numSegments; ++i ) {
      widthTotal += getTextWidth( texts[i], fontsize );
    }
    iStartingX = ix - widthTotal/2;
  } else {
    iStartingX = ix;
  }
  
  for( int i = 0; i < numSegments; ++i ) {
    plotText( texts[i], fontsize, false, iStartingX, iy, angle, fores[i], backs[i] );
    iStartingX += getTextWidth( texts[i], fontsize );
  }
}



void SC2Map::gradient( float   zeroToOne,
                       int     numColors,
                       string* colorBaseName,
                       Color*  cOut ) {
  
  Color* low;
  Color* high;

  char colorNameC[FILENAME_LENGTH];    

  string colorName;

    
  // off the scale?
  if( zeroToOne <= 0.0f ) {
    sprintf( colorNameC, "%s%d", colorBaseName->c_str(), 0 );
    colorName.assign( colorNameC );
    low = getColor( colorName );
    cOut->r = low->r;
    cOut->g = low->g;
    cOut->b = low->b;
    return;
  }
  if( zeroToOne >= 1.0f ) {
    sprintf( colorNameC, "%s%d", colorBaseName->c_str(), numColors );
    colorName.assign( colorNameC );
    high = getColor( colorName );
    cOut->r = high->r;
    cOut->g = high->g;
    cOut->b = high->b;
    return;  
  }
  
  // otherwise find the right interval
  float d = zeroToOne * ((float)(numColors - 1));
  
  int lowColor  = ((int) floor( d )) + 1;
  
  if( lowColor == numColors ) { 
    printError( "Unexpected floating point result in gradient().\n" );
    printError( "numColors=%d, zeroToOne=%f, d=%f, lowColor=%d.\n",
                numColors, zeroToOne, d, lowColor );
    exit( -1 );
  }
  int highColor = lowColor + 1;
  
  sprintf( colorNameC, "%s%d", colorBaseName->c_str(), lowColor );
  colorName.assign( colorNameC );
  low = getColor( colorName );

  sprintf( colorNameC, "%s%d", colorBaseName->c_str(), highColor );
  colorName.assign( colorNameC );
  high = getColor( colorName );
  
  d -= floor( d );
  
  // now use 0.0 <= d <= 1.0 to calculate
  // a gradient between the chosen low/high color
  cOut->r = low->r + d*(high->r - low->r);
  cOut->g = low->g + d*(high->g - low->g);
  cOut->b = low->b + d*(high->b - low->b);
}








int SC2Map::pngwriterTest() {
  pngwriter test( 10, 10, 1.0f, "dummy.png" );

  char fontface[] = "./FreeSansBold.ttf";

  errno = 0;

  test.plot_text( fontface, 10, 0, 0, 0.0f, (char*)"test", 1.0f, 1.0f, 1.0f );

  return errno;
}
void SC2Map::renderTestAllPaths() {
  renderTerrain();

  StartLoc* sl0 = startLocs.front();

  plotAllShortestPaths( &(sl0->loc), PATH_GROUND_WITHROCKS );
}
void SC2Map::plotAllShortestPaths( point* p, PathType t ) {
  float r = 1.0f;
  float g = 1.0f;
  float b = 0.0f;

  Node* src = getPathNode( p, t );

  for( int pci = 0; pci < cxDimPlayable; ++pci )
  {
    for( int pcj = 0; pcj < cyDimPlayable; ++pcj )
    {
      point c; c.pcSet( pci, pcj );
      Node* u = getPathNode( &c, t );
      if( u == NULL ) { continue; }

      Node* v = getShortestPathPredecessor( src, u, t );
      if( v == NULL ) { continue; }

      img->arrow( ix2png( u->loc.ix ), iy2png( u->loc.iy ),
                  ix2png( v->loc.ix ), iy2png( v->loc.iy ),
                  4, 0.4f,
                  r, g, b );
    }
  }
}
void SC2Map::renderTestPathingFills() {
  renderTerrain();
  renderPathing( PATH_GROUND_NOROCKS );

  for( list<point>::const_iterator itr = pathingFillsToRender.begin();
       itr != pathingFillsToRender.end();
       ++itr )
  {
    point c;
    c.pcSet( (*itr).pcx, (*itr).pcy );

    int x0 = ix2png( c.ix - iDimC/2 );
    int y0 = iy2png( c.iy - iDimC/2 );

    img->filledsquare( x0 + 2,
                       y0 + 2,
                       x0 + 3,
                       y0 + 3,
                       0.0f, 1.0f, 1.0f
                     );
  }
}
void SC2Map::renderTestFrameTranslation() {
  float r, g, b;

  img->filledsquare( iLeft, iBottom, iRight - 1, iTop - 1, 0.2f, 0.2f, 0.0f );


  renderTerrain();

  r = 1.0f; g = 0.0f; b = 0.0f;
  img->plot( ix2png( 0 ), iy2png( 0 ), r, g, b );
  //plotText( "image frame origin", 10, true, iLeft, iBottom-10,
  //          0.0f, r, g, b, 0.0f, 0.0f, 0.0f );

  // when the map (mcLeft, mcBottom) = (26, 20) then
  // this point should appear in the center of the
  // playable cell (0, 0)
  r = 0.0f; g = 1.0f; b = 0.0f;
  point p1; p1.mSet( 26.5f, 20.5f );
  img->plot( ix2png( p1.ix ), iy2png( p1.iy ), r, g, b );


  // this point should appear in the center of
  // playable terrain unit (1, 2)
  r = 0.0f; g = 0.0f; b = 1.0f;
  point p2; p2.ptSet( 1, 2 );
  img->plot( ix2png( p2.ix ), iy2png( p2.iy ), r, g, b );

  // and playable terrain unit (2, 2)
  p2.ptSet( 2, 2 );
  img->plot( ix2png( p2.ix ), iy2png( p2.iy ), r, g, b );

  // and playable terrain unit (1, 3)
  p2.ptSet( 1, 3 );
  img->plot( ix2png( p2.ix ), iy2png( p2.iy ), r, g, b );



  // this point should appear in the center of
  // playable cell (3, 1)
  r = 0.0f; g = 1.0f; b = 1.0f;
  point p3; p3.pcSet( 3, 1 );
  img->plot( ix2png( p3.ix ), iy2png( p3.iy ), r, g, b );

  // and playable cell (4, 1)
  p3.pcSet( 4, 1 );
  img->plot( ix2png( p3.ix ), iy2png( p3.iy ), r, g, b );

  // and playable cell (5, 2)
  p3.pcSet( 5, 2 );
  img->plot( ix2png( p3.ix ), iy2png( p3.iy ), r, g, b );

  p3.pcSet( 0, 0 );
  img->plot( ix2png( p3.ix ), iy2png( p3.iy ), r, g, b );
}
void SC2Map::renderTestClockFaceDetection() {
  float upperBounds[13];

  // each wedge of clock is 1/12 of 2*pi, or pi/6
  float wedge = M_PI / 6.0f;

  // the upper bound of 9 o'clock's BOTTOM half is half a wedge
  // over the bottom of the range
  float bound = -M_PI + 0.5f*wedge;

  for( int i = 0; i < 13; ++i )
  {
    upperBounds[i] = bound;
    bound += wedge;
  }

  // start at bottom of range, go positive radians around clock
  float wedgeColors[][3] =
  {
    { 1.0f, 0.0f, 0.0f }, // 9
    { 0.0f, 1.0f, 0.0f }, // 8
    { 0.0f, 0.0f, 1.0f }, // 7
    { 1.0f, 1.0f, 0.0f }, // 6
    { 0.0f, 1.0f, 1.0f }, // 5
    { 1.0f, 0.0f, 1.0f }, // 4
    { 1.0f, 0.0f, 0.0f }, // 3
    { 0.0f, 1.0f, 0.0f }, // 2
    { 0.0f, 0.0f, 1.0f }, // 1
    { 1.0f, 1.0f, 0.0f }, // 12
    { 0.0f, 1.0f, 1.0f }, // 11
    { 1.0f, 0.0f, 1.0f }, // 10
    { 1.0f, 0.0f, 0.0f }, // 9
  };

  // set a point at the playable terrain's center
  // to calculate the angle to a start location
  point center;
  center.ptSet( txDimPlayable/2,
                tyDimPlayable/2 );

  for( int pci = 0; pci < cxDimPlayable; ++pci )
  {
    for( int pcj = 0; pcj < cyDimPlayable; ++pcj )
    {
      point c;
      c.pcSet( pci, pcj );

      float* rgb;

      // TODO alter angle for aspect ratio?
      float ang = atan2( c.my - center.my, c.mx - center.mx );

      for( int i = 0; i < 13; ++i )
      {
        if( ang < upperBounds[i] )
        {
          rgb = wedgeColors[i];
          break;
        }
      }

      Color color;
      color.r = rgb[0];
      color.g = rgb[1];
      color.b = rgb[2];
      plotCellPoint( &c, &color );
    }
  }
}
void SC2Map::renderTestDetectChokes() {
  renderTerrain();
  renderOpenness( PATH_GROUND_NOROCKS );

  for( list<point>::const_iterator itr = opennessNeighborhoodsToRender.begin();
       itr != opennessNeighborhoodsToRender.end();
       ++itr )
  {
    point c;
    c.pcSet( (*itr).pcx, (*itr).pcy );

    int x0 = ix2png( c.ix - iDimT/2 );
    int y0 = iy2png( c.iy - iDimT/2 );

    img->filledsquare( x0,
                       y0,
                       x0 + iDimT - 1,
                       y0 + iDimT - 1,
                       0.0f, 1.0f, 1.0f
                     );

    //float ano = calculateAverageOpennessInNeighborhood( &c,
    //                                                    getfConstant( "chokeDetectionRadius" ),
    //                                                    PATH_GROUND_WITHROCKS );
    //img->circle( ix2png( c.ix ),
    //             iy2png( c.iy ),
    //             iDimT * (int)getfConstant( "chokeDetectionRadius" ),
    //             1.0f, 1.0f, 1.0f );

    float dChoke = chokeDistance( &c, PATH_GROUND_WITHROCKS );

    char text[50];
    sprintf( text,
             "%.1f",
             dChoke );

    plotText( text,
              18,          // font size
              true,       // centered,
              ix2png( c.ix ), iy2png( c.iy ) - 18,
              0.0f,        // angle
              getColor( "defaultTxtFg" ),
              getColor( "defaultTxtBg" ) );
  }
}
void SC2Map::renderTestImages() {
  //resetPNGWriter( "-test-frame-translation",
  //                3, 7, // left, right borders
  //                11, 4  // top, bottom border
  //              );
  //renderTestFrameTranslation();
  //img->close();

  //resetPNGWriter( "-test-clock-face-detection",
  //                5, 5, // left, right borders
  //                5, 5  // top, bottom border
  //              );
  //renderTestClockFaceDetection();
  //img->close();

  //resetPNGWriter( "-test-all-paths",
  //                5, 5, // left, right borders
  //                5, 5  // top, bottom border
  //              );
  //renderTestAllPaths();
  //img->close();

  //resetPNGWriter( "-test-pathings-fills",
  //                5, 5, // left, right borders
  //                5, 5  // top, bottom border
  //              );
  //renderTestPathingFills();
  //img->close();

  //resetPNGWriter( "-test-detect-chokes",
  //                5, 5, // left, right borders
  //                5, 5  // top, bottom border
  //              );
  //renderTestDetectChokes();
  //img->close();
}
